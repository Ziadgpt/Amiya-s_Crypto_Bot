import sqlite3
import pandas as pd
import multiprocessing as mp
from utils.logger import setup_logger

# Import only non-TF models at the top level
from models.bollinger_bands import backtest_bollinger_bands
from models.formula_7 import backtest_formula_7
from models.hmm_regime import backtest_hmm
from execution import place_order

logger = setup_logger('strategy', 'strategy.log')


def combine_signals(market='BTC-USD'):
    """
    Combines signals from Formula 7 and HMM into a single dataframe.
    """
    df_f7 = backtest_formula_7(market)
    df_hmm = backtest_hmm(market)

    if df_f7.empty or df_hmm.empty:
        logger.error(f"No data for {market}")
        return None

    df = df_f7[['started_at', 'f7_signal']].merge(
        df_hmm[['started_at', 'hmm_signal']], on='started_at'
    )

    df['combined_signal'] = 0
    df.loc[(df['f7_signal'] == 1) & (df['hmm_signal'] == 1), 'combined_signal'] = 1  # Buy
    df.loc[(df['f7_signal'] == -1) & (df['hmm_signal'] == -1), 'combined_signal'] = -1  # Sell

    logger.info(f"Combined signals for {market}: {df['combined_signal'].value_counts().to_dict()}")
    print(f"Combined signals for {market}: {df['combined_signal'].value_counts().to_dict()}")

    return df


def _run_lstm_in_process(market, queue):
    """
    Runs the LSTM backtest in a separate process to avoid TensorFlow deadlocks.
    """
    try:
        # Import TensorFlow & Keras ONLY inside the child process
        import tensorflow as tf
        import keras
        from models.lstm_model import backtest_lstm

        # Run supporting models first (if they are prerequisites for LSTM data)
        backtest_bollinger_bands(market)
        backtest_hmm(market)
        backtest_formula_7(market)

        df = backtest_lstm(market)
        queue.put(df)

    except Exception as e:
        logger.error(f"Error in LSTM process for {market}: {e}")
        queue.put(pd.DataFrame())


def execute_trades(market='BTC-USD'):
    """
    Executes trades by running the LSTM model in an isolated process.
    """
    logger.info(f"Starting the trading strategy for {market}...")

    # Use a Queue to get the result from the child process
    q = mp.Queue()

    # Run the LSTM process safely with spawn
    p = mp.Process(target=_run_lstm_in_process, args=(market, q))
    p.start()
    p.join()

    # Get result
    if q.empty():
        logger.error("No result returned from LSTM process.")
        return

    df = q.get()

    if df.empty or 'lstm_signal' not in df.columns:
        logger.error(f"Final dataframe from LSTM process is empty or missing signals. Cannot execute trade.")
        return

    latest_signal = df['lstm_signal'].iloc[-1]
    latest_price = df['close'].iloc[-1]

    if latest_signal == 1:
        logger.info(f"BUY signal generated by LSTM for {market} at ${latest_price:.2f}")
        place_order(market, 'buy', 0.01, latest_price)
    elif latest_signal == -1:
        logger.info(f"SELL signal generated by LSTM for {market} at ${latest_price:.2f}")
        place_order(market, 'sell', 0.01, latest_price)
    else:
        logger.info(f"No trade signal generated by LSTM for {market}.")


if __name__ == "__main__":
    # Ensure safe multiprocessing start method
    mp.set_start_method("spawn", force=True)

    # Example run
    execute_trades("BTC-USD")
